#!/bin/bash -el

# Copyright 2025 tsuru authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

SOURCE_DIR=/var/lib/tsuru
source ${SOURCE_DIR}/base/deploy
source ${SOURCE_DIR}/base/rc/config

PYTHON_REPO=${PYTHON_REPO:-https://heroku-buildpack-python.s3.amazonaws.com}
GET_PIP_URL=${GET_PIP_URL:-https://bootstrap.pypa.io/get-pip.py}
GET_PIP_VERSION_URL=${GET_PIP_VERSION_URL:-https://bootstrap.pypa.io/pip/@VERSION@/get-pip.py}

# Load latest Python versions from file generated during install
PYTHON_VERSIONS_FILE="${SOURCE_DIR}/python/latest_versions.sh"
if [ -f "$PYTHON_VERSIONS_FILE" ]; then
    source "$PYTHON_VERSIONS_FILE"
else
    echo "ERROR: Python versions file not found at $PYTHON_VERSIONS_FILE"
    echo "This file should have been generated during platform installation."
    exit 1
fi
ARCH=$(uname -m)
if [ "$ARCH" == "x86_64" ]; then
    ARCH="amd64"
elif [ "$ARCH" == "aarch64" ]; then
    ARCH="arm64"
fi
UBUNTU_RELEASE=$(. /etc/os-release && echo $VERSION_ID)
# Extract all LATEST_* versions from the sourced file and sort them in descending order
LATEST_PYTHON_VERSIONS=($(grep -oE 'LATEST_[0-9]+="[^"]+"' "$PYTHON_VERSIONS_FILE" | cut -d'"' -f2 | sort -Vr))
PYTHON_VERSION_DEFAULT="${PYTHON_VERSION_DEFAULT:-${LATEST_PYTHON_VERSIONS[0]}}"
VERSION_ORIGIN="default"
PYTHON_BASE_DIR="/home/application/python"
INSTALLED_PYTHON_FILE="${PYTHON_BASE_DIR}/.installed-version"

# Check if Pipfile.lock specifies a Python version first
PIPFILE_PYTHON_VERSION=""
if [ -f "${CURRENT_DIR}/Pipfile.lock" ]; then
    # Use jq to parse JSON instead of Python
    PIPFILE_PYTHON_VERSION=$(jq -r '._meta.requires.python_version // empty' "${CURRENT_DIR}/Pipfile.lock" 2>/dev/null || echo "")
fi

# Set version based on priority: Pipfile.lock > PYTHON_VERSION env var > .python-version file > default
# Pipfile.lock has highest priority because pipenv will fail if versions don't match
if [ -n "${PIPFILE_PYTHON_VERSION}" ]; then
    PYTHON_VERSION="${PIPFILE_PYTHON_VERSION}"
    VERSION_ORIGIN="Pipfile.lock"
elif [ -n "${PYTHON_VERSION}" ]; then
    VERSION_ORIGIN="PYTHON_VERSION environment variable"
elif [ -f "${CURRENT_DIR}/.python-version" ]; then
    tmp_version=$(cat "${CURRENT_DIR}/.python-version")
    if [ -n "${tmp_version}" ]; then
        PYTHON_VERSION=${tmp_version}
        VERSION_ORIGIN=".python-version file"
    fi
else
    PYTHON_VERSION="${PYTHON_VERSION_DEFAULT}"
fi

INSTALL_PYTHON=1
if [[ -f ${PYTHON_BASE_DIR}/bin/python ]] && [[ -f ${INSTALLED_PYTHON_FILE} ]]; then
    INSTALLED_VERSION=$(cat ${INSTALLED_PYTHON_FILE})
    if [[ ${INSTALLED_VERSION} == ${PYTHON_VERSION} ]]; then
        echo "-- Using already installed python version: ${INSTALLED_VERSION} --"
        INSTALL_PYTHON=0
    fi
fi

function choose_closest_python() {
    IFS=$'\n'
    local VERSIONS=$(sort -rV <<<"${LATEST_PYTHON_VERSIONS[*]}")
    unset IFS
    local TRY_PYTHON_VERSION="$1"
    local CHOSEN_PYTHON_VERSION=""
    local LAST_PYTHON_VERSION=""
    while [[ "${LAST_PYTHON_VERSION}" != "${TRY_PYTHON_VERSION}" ]]; do
        if echo "${VERSIONS}" | grep "^${TRY_PYTHON_VERSION}" >/dev/null; then
            CHOSEN_PYTHON_VERSION=$(echo "${VERSIONS}" | grep "^${TRY_PYTHON_VERSION}" | head -1)
            break
        fi
        LAST_PYTHON_VERSION="${TRY_PYTHON_VERSION}"
        TRY_PYTHON_VERSION=$(echo ${TRY_PYTHON_VERSION} | sed -E 's/(.*)(\.|-)[^\.]*$/\1/g')
    done
    echo "${CHOSEN_PYTHON_VERSION}"
}

function install_python() {
    DOWNLOAD_VERSION=${PYTHON_VERSION}
    if [[ ${DOWNLOAD_VERSION} =~ ^[0-9]\..* ]]; then
        DOWNLOAD_VERSION="python-${DOWNLOAD_VERSION}"
    fi

    DOWNLOAD_URL="${PYTHON_REPO}/${DOWNLOAD_VERSION}-ubuntu-${UBUNTU_RELEASE}-${ARCH}.tar.zst"
    if ! curl -m 10 -o/dev/null -ILfs $DOWNLOAD_URL; then
        # The exact requested version returned an http error so it's probably
        # not available, let's try finding the closest one.
        NEW_PYTHON_VERSION=$(choose_closest_python $PYTHON_VERSION)

        if [[ "${NEW_PYTHON_VERSION}" == "" ]]; then
            echo "Python version '${PYTHON_VERSION}' (${VERSION_ORIGIN}) is not supported."
            PYTHON_VERSION="${PYTHON_VERSION_DEFAULT}"
            VERSION_ORIGIN="default"
        elif [[ "${NEW_PYTHON_VERSION}" != "${PYTHON_VERSION}" ]]; then
            echo "Exact python version '${PYTHON_VERSION}' (${VERSION_ORIGIN}) is not supported."
            echo "Closest version is '${NEW_PYTHON_VERSION}'."
            PYTHON_VERSION="${NEW_PYTHON_VERSION}"
            VERSION_ORIGIN="${VERSION_ORIGIN} (closest)"
        fi
    fi

    if [[ ${INSTALLED_VERSION} == ${PYTHON_VERSION} ]]; then
        echo "-- Using already installed python version: ${INSTALLED_VERSION} --"
        return
    fi

    DOWNLOAD_VERSION=${PYTHON_VERSION}
    if [[ ${DOWNLOAD_VERSION} =~ ^[0-9]\..* ]]; then
        DOWNLOAD_VERSION="python-${DOWNLOAD_VERSION}"
    fi
    DOWNLOAD_URL="${PYTHON_REPO}/${DOWNLOAD_VERSION}-ubuntu-${UBUNTU_RELEASE}-${ARCH}.tar.zst"

    # install python binaries
    rm -rf "${PYTHON_BASE_DIR}"
    mkdir -p "${PYTHON_BASE_DIR}"
    echo "-- Using python version: ${PYTHON_VERSION} (${VERSION_ORIGIN}) from $DOWNLOAD_URL --"
    if ! (curl -m 120 -sS --retry 3 -L "$DOWNLOAD_URL" | tar --zstd -x -C "${PYTHON_BASE_DIR}"); then
        echo "ERROR: python version $PYTHON_VERSION is not supported."
        exit 1
    fi

    sudo ldconfig
    hash -r

    major_minor=""
    if [[ ${PYTHON_VERSION} =~ [0-9]+\.[0-9]+ ]]; then
        major_minor=${BASH_REMATCH[0]}

        GET_PIP_VERSION_URL=${GET_PIP_VERSION_URL/@VERSION@/${major_minor}}
        if curl -m 10 -o/dev/null -ILfs $GET_PIP_VERSION_URL; then
            GET_PIP_URL=$GET_PIP_VERSION_URL
        fi
    fi

    # install pip
    if [[ "${PYTHON_PIP_VERSION}" ]]; then
        PIP_VERSION_SPEC="${PYTHON_PIP_VERSION}"
        if [[ "$PYTHON_PIP_VERSION" =~ ^[0-9] ]]; then
            if [[ ${PYTHON_PIP_VERSION/.*/} -lt 19 ]]; then
                PIP_EXTRA_OPTS="--process-dependency-links"
            fi
            PIP_VERSION_SPEC="==${PYTHON_PIP_VERSION}"
        fi
        echo "Using pip version ${PIP_VERSION_SPEC}"
        curl -m 120 -LsS ${GET_PIP_URL} | python - "pip${PIP_VERSION_SPEC}"
    else
        echo "Using default pip version"
        curl -m 120 -LsS ${GET_PIP_URL} | python
    fi

    echo ${PYTHON_VERSION} >${INSTALLED_PYTHON_FILE}
}

if [[ ${INSTALL_PYTHON} == 1 ]]; then
    install_python
fi

# install project deps with pipenv or pip
pushd "$CURRENT_DIR"
if [ -f "${CURRENT_DIR}/Pipfile.lock" ]; then
    echo "Pipfile.lock detected, using 'pipenv install --system --deploy' to install dependencies"

    PIPENV_VERSION_SPEC=""
    if [[ "${PYTHON_PIPENV_VERSION}" != "" ]]; then
        PIPENV_VERSION_SPEC="${PYTHON_PIPENV_VERSION}"
        if [[ "$PYTHON_PIPENV_VERSION" =~ ^[0-9] ]]; then
            PIPENV_VERSION_SPEC="==${PYTHON_PIPENV_VERSION}"
        fi
        echo "Using pipenv version ${PIPENV_VERSION_SPEC}"
    else
        echo "Using latest pipenv version"
    fi
    pip install pipenv${PIPENV_VERSION_SPEC}
    pipenv install --system --deploy
elif [ -f "${CURRENT_DIR}/requirements.txt" ]; then
    echo "requirements.txt detected, using 'pip install -r ./requirements.txt' to install dependencies"
    pip install -r ./requirements.txt
elif [ -f "${CURRENT_DIR}/setup.py" ]; then
    echo "setup.py detected, using 'pip install -e .' to install dependencies"
    pip install ${PIP_EXTRA_OPTS:-} -e .
fi
popd
